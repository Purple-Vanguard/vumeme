name: Codex MVP Autopilot (GITHUB_TOKEN only)

on:
  workflow_dispatch: {}
  schedule:
    - cron: "*/10 * * * *"

concurrency:
  group: codex-mvp-autopilot
  cancel-in-progress: false

permissions:
  contents: write
  pull-requests: write
  issues: write
  checks: read

jobs:
  autopilot:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Pause switch
        run: |
          if [ -f CODEX_PAUSE ]; then
            echo "CODEX_PAUSE present. Exiting."
            exit 0
          fi

      - name: Codex MVP loop (dispatch / fix / merge)
        uses: actions/github-script@v7
        env:
          CODEX_DRIVER_PR: ${{ vars.CODEX_DRIVER_PR }}
          CODEX_BASE_BRANCH: ${{ vars.CODEX_BASE_BRANCH }}
          MAX_FIX_ATTEMPTS: "8"
          DISPATCH_COOLDOWN_MINUTES: "30"
        with:
          github-token: ${{ github.token }}
          script: |
            const fs = require("fs");
            const path = require("path");

            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const baseBranch = process.env.CODEX_BASE_BRANCH || "main";
            const driverPr = Number(process.env.CODEX_DRIVER_PR || "");
            if (!driverPr) {
              core.setFailed("Missing CODEX_DRIVER_PR repo variable.");
              return;
            }

            const MAX_FIX_ATTEMPTS = Number(process.env.MAX_FIX_ATTEMPTS || "8");
            const DISPATCH_COOLDOWN_MINUTES = Number(process.env.DISPATCH_COOLDOWN_MINUTES || "30");

            const MVP_ORDER = ["00","01","02","03","04","05","06"];
            const MARKER = "<!-- CODEX_AUTOPILOT -->";

            function minutesAgo(iso) {
              return (Date.now() - new Date(iso).getTime()) / 60000;
            }

            async function listOpenCodexPRs() {
              const prs = await github.rest.pulls.list({
                owner, repo,
                state: "open",
                base: baseBranch,
                per_page: 100,
              });
              return prs.data.filter(pr => (pr.head.ref || "").startsWith("codex/"));
            }

            async function getCheckSummary(sha) {
              const res = await github.rest.checks.listForRef({
                owner, repo, ref: sha, per_page: 100,
              });
              const runs = res.data.check_runs || [];
              const completed = runs.filter(r => r.status === "completed");
              const anyFailed = completed.some(r =>
                ["failure","cancelled","timed_out","action_required","stale"].includes(r.conclusion)
              );
              const anyInProgress = runs.some(r => r.status !== "completed");
              return { anyFailed, anyInProgress, completed };
            }

            async function getMergeable(prNumber) {
              for (let i = 0; i < 6; i++) {
                const pr = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
                if (pr.data.mergeable !== null) return pr.data.mergeable;
                await new Promise(r => setTimeout(r, 1500));
              }
              const pr = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
              return pr.data.mergeable;
            }

            async function listComments(issueNumber) {
              const res = await github.rest.issues.listComments({
                owner, repo, issue_number: issueNumber, per_page: 100,
              });
              return res.data;
            }

            function parseLastFixAttempt(comments) {
              const fixes = comments
                .filter(c => (c.body || "").includes(MARKER) && (c.body || "").includes("fix-attempt"))
                .sort((a,b) => new Date(a.created_at) - new Date(b.created_at));
              if (fixes.length === 0) return { count: 0, lastSha: null };
              const last = fixes[fixes.length - 1];
              const m = (last.body || "").match(/sha:\s*([0-9a-f]{7,40})/i);
              return { count: fixes.length, lastSha: m ? m[1] : null };
            }

            function parseLastDispatch(comments) {
              const ds = comments
                .filter(c => (c.body || "").includes(MARKER) && (c.body || "").includes("dispatch:"))
                .sort((a,b) => new Date(a.created_at) - new Date(b.created_at));
              return ds.length ? ds[ds.length - 1] : null;
            }

            function pickNextPRD() {
              const idxPath = path.join(process.cwd(), "prd", "index.md");
              if (!fs.existsSync(idxPath)) return null;
              const lines = fs.readFileSync(idxPath, "utf-8").split(/\r?\n/);

              let nextId = null;
              for (const pid of MVP_ORDER) {
                const re = new RegExp(`^- \\[TODO\\] PRD-${pid}\\b`);
                if (lines.some(l => re.test(l))) { nextId = pid; break; }
              }
              if (!nextId) return null;

              const prdDir = path.join(process.cwd(), "prd");
              const files = fs.readdirSync(prdDir).filter(f => f.startsWith(`PRD-${nextId}-`) && f.endsWith(".md"));
              files.sort();
              return { id: `PRD-${nextId}`, file: `prd/${files[0]}` };
            }

            async function commentDriverDispatch(prd) {
              const body = [
                MARKER,
                `@codex Implement **${prd.id}** on base branch \`${baseBranch}\`.`,
                ``,
                `Rules (must follow):`,
                `- Read: \`agent.md\`, \`process.txt\`, \`prd/index.md\`, and \`${prd.file}\`.`,
                `- Implement ONLY the PRD "In Scope".`,
                `- Run the PRD Test Steps and report results in the PR description.`,
                `- Update \`prd/index.md\`: mark ${prd.id} as DONE.`,
                `- Append a new round block to \`process.txt\`.`,
                `- Open a NEW PR into \`${baseBranch}\` titled: "Codex: ${prd.id}".`,
                `- Head branch MUST start with \`codex/\`.`,
                `- If CI fails, keep fixing within the SAME PR until it passes.`,
                ``,
                `dispatch: ${prd.id}`,
                `time: ${new Date().toISOString()}`
              ].join("\n");

              await github.rest.issues.createComment({
                owner, repo, issue_number: driverPr, body,
              });
            }

            async function commentFixCI(prNumber, sha, attempt, last) {
              const body = [
                MARKER,
                `@codex Fix ONLY the CI failures for this PR. Do NOT add features.`,
                ``,
                `fix-attempt: ${attempt}/${MAX_FIX_ATTEMPTS}`,
                `sha: ${sha}`,
                last ? `previous-attempt-sha: ${last}` : "",
                `time: ${new Date().toISOString()}`
              ].filter(Boolean).join("\n");

              await github.rest.issues.createComment({
                owner, repo, issue_number: prNumber, body,
              });
            }

            async function mergePR(pr) {
              await github.rest.pulls.merge({
                owner, repo,
                pull_number: pr.number,
                merge_method: "squash",
                commit_title: `Automerge: ${pr.title}`,
              });
            }

            // === Main loop ===
            const codexPRs = await listOpenCodexPRs();

            if (codexPRs.length === 1) {
              const pr = codexPRs[0];
              const checks = await getCheckSummary(pr.head.sha);

              if (checks.anyFailed) {
                const comments = await listComments(pr.number);
                const { count, lastSha } = parseLastFixAttempt(comments);

                if (lastSha && lastSha.startsWith(pr.head.sha.slice(0, Math.min(lastSha.length, pr.head.sha.length)))) {
                  core.info("Already requested fix for current SHA. Waiting.");
                  return;
                }
                if (count >= MAX_FIX_ATTEMPTS) {
                  core.warning("Exceeded MAX_FIX_ATTEMPTS. Stopping.");
                  return;
                }
                await commentFixCI(pr.number, pr.head.sha, count + 1, lastSha);
                return;
              }

              if (checks.anyInProgress) return;

              const mergeable = await getMergeable(pr.number);
              if (mergeable === false) return;

              await mergePR(pr);
              core.info(`Merged PR #${pr.number}.`);
              return;
            }

            if (codexPRs.length > 1) {
              core.warning("Multiple codex/* PRs open; stopping.");
              return;
            }

            // No open codex PR => dispatch next PRD (with cooldown)
            const prd = pickNextPRD();
            if (!prd) {
              core.info("No TODO PRDs left. Done.");
              return;
            }

            const driverComments = await listComments(driverPr);
            const lastDispatch = parseLastDispatch(driverComments);
            if (lastDispatch) {
              const ageMin = minutesAgo(lastDispatch.created_at);
              if (ageMin < DISPATCH_COOLDOWN_MINUTES) {
                core.info(`Cooling down (${ageMin.toFixed(1)} min).`);
                return;
              }
            }

            await commentDriverDispatch(prd);
            core.info(`Dispatched ${prd.id} via driver PR #${driverPr}.`);
