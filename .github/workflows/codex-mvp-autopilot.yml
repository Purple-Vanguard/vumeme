name: Codex MVP Autopilot (No PAT for GitHub API)

on:
  workflow_dispatch: {}
  schedule:
    - cron: "*/10 * * * *" # keep as-is for now

concurrency:
  group: codex-mvp-autopilot
  cancel-in-progress: false

permissions:
  contents: write
  pull-requests: write
  issues: write
  checks: read

jobs:
  autopilot:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Pause switch
        run: |
          if [ -f CODEX_PAUSE ]; then
            echo "CODEX_PAUSE present. Exiting."
            exit 0
          fi

      - name: Codex MVP loop (dispatch / fix / merge)
        uses: actions/github-script@v7
        env:
          CODEX_DRIVER_PR: ${{ vars.CODEX_DRIVER_PR }}
          CODEX_BASE_BRANCH: ${{ vars.CODEX_BASE_BRANCH }}
          MAX_FIX_ATTEMPTS: "8"
          DISPATCH_COOLDOWN_MINUTES: "30"
          STUCK_AFTER_MINUTES: "90"
        with:
          # IMPORTANT: use GitHub Actions token (NOT a PAT)
          github-token: ${{ github.token }}
          script: |
            const fs = require("fs");
            const path = require("path");

            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const baseBranch = process.env.CODEX_BASE_BRANCH || "main";
            const driverPr = Number(process.env.CODEX_DRIVER_PR || "");
            if (!driverPr) {
              core.setFailed("Missing CODEX_DRIVER_PR repo variable (the always-open driver PR number).");
              return;
            }

            const MAX_FIX_ATTEMPTS = Number(process.env.MAX_FIX_ATTEMPTS || "8");
            const DISPATCH_COOLDOWN_MINUTES = Number(process.env.DISPATCH_COOLDOWN_MINUTES || "30");
            const STUCK_AFTER_MINUTES = Number(process.env.STUCK_AFTER_MINUTES || "90");

            const MVP_ORDER = ["00","01","02","03","04","05","06"];
            const MARKER = "<!-- CODEX_AUTOPILOT -->";

            function minutesAgo(iso) {
              const then = new Date(iso).getTime();
              const now = Date.now();
              return (now - then) / 60000;
            }

            async function listOpenCodexPRs() {
              const prs = await github.rest.pulls.list({
                owner, repo,
                state: "open",
                base: baseBranch,
                per_page: 100,
              });
              return prs.data.filter(pr => (pr.head.ref || "").startsWith("codex/"));
            }

            async function getCheckSummary(sha) {
              const res = await github.rest.checks.listForRef({
                owner, repo,
                ref: sha,
                per_page: 100,
              });
              const runs = res.data.check_runs || [];
              const completed = runs.filter(r => r.status === "completed");
              const anyFailed = completed.some(r =>
                ["failure", "cancelled", "timed_out", "action_required", "stale"].includes(r.conclusion)
              );
              const anyInProgress = runs.some(r => r.status !== "completed");
              const allSuccess = completed.length > 0 && completed.every(r => r.conclusion === "success");
              return { runs, completed, anyFailed, anyInProgress, allSuccess };
            }

            async function getMergeable(prNumber) {
              for (let i = 0; i < 6; i++) {
                const pr = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
                if (pr.data.mergeable !== null) return pr.data.mergeable;
                await new Promise(r => setTimeout(r, 1500));
              }
              const pr = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
              return pr.data.mergeable;
            }

            async function listComments(issueNumber) {
              const res = await github.rest.issues.listComments({
                owner, repo,
                issue_number: issueNumber,
                per_page: 100,
              });
              return res.data;
            }

            function parseLastFixAttempt(comments) {
              const fixes = comments
                .filter(c => (c.body || "").includes(MARKER) && (c.body || "").includes("fix-attempt"))
                .sort((a,b) => new Date(a.created_at) - new Date(b.created_at));
              if (fixes.length === 0) return { count: 0, lastSha: null, lastCreatedAt: null };
              const last = fixes[fixes.length - 1];
              const m = (last.body || "").match(/sha:\s*([0-9a-f]{7,40})/i);
              return { count: fixes.length, lastSha: m ? m[1] : null, lastCreatedAt: last.created_at };
            }

            function parseLastDispatch(comments) {
              const ds = comments
                .filter(c => (c.body || "").includes(MARKER) && (c.body || "").includes("dispatch:"))
                .sort((a,b) => new Date(a.created_at) - new Date(b.created_at));
              if (ds.length === 0) return null;
              const last = ds[ds.length - 1];
              const m = (last.body || "").match(/dispatch:\s*(PRD-\d+)/i);
              return { comment: last, prdId: m ? m[1] : null };
            }

            function hasCodexAckAfter(comments, sinceIso) {
              const since = new Date(sinceIso).getTime();
              return comments.some(c => {
                const t = new Date(c.created_at).getTime();
                if (t <= since) return false;
                const login = (c.user && c.user.login) ? c.user.login : "";
                const body = c.body || "";
                // adjust these heuristics to your actual bot login/body patterns
                return (
                  login.includes("codex") ||
                  login.includes("chatgpt-codex-connector") ||
                  body.includes("View task") ||
                  body.includes("Summary")
                );
              });
            }

            function pickNextPRD() {
              const idxPath = path.join(process.cwd(), "prd", "index.md");
              if (!fs.existsSync(idxPath)) return null;
              const lines = fs.readFileSync(idxPath, "utf-8").split(/\r?\n/);

              let nextId = null;
              for (const pid of MVP_ORDER) {
                const re = new RegExp(`^- \\[TODO\\] PRD-${pid}\\b`);
                if (lines.some(l => re.test(l))) { nextId = pid; break; }
              }
              if (!nextId) return null;

              const prdDir = path.join(process.cwd(), "prd");
              const files = fs.readdirSync(prdDir).filter(f => f.startsWith(`PRD-${nextId}-`) && f.endsWith(".md"));
              if (files.length === 0) return { id: `PRD-${nextId}`, file: null };
              files.sort();
              return { id: `PRD-${nextId}`, file: `prd/${files[0]}` };
            }

            async function commentDriverDispatch(prd) {
              const body = [
                MARKER,
                `@codex Implement **${prd.id}** on base branch \`${baseBranch}\`.`,
                ``,
                `Rules (must follow):`,
                `- Read: \`agent.md\`, \`process.txt\`, \`prd/index.md\`, and \`${prd.file}\`.`,
                `- Implement ONLY the PRD "In Scope".`,
                `- Run the PRD Test Steps and report results in the PR description.`,
                `- Update \`prd/index.md\`: mark ${prd.id} as DONE.`,
                `- Append a new round block to \`process.txt\` (Goal / shipped / acceptance / lessons / next).`,
                `- Open a NEW PR into \`${baseBranch}\` titled: "Codex: ${prd.id}".`,
                `- Use a head branch starting with \`codex/\` (required by autopilot).`,
                `- If CI fails, keep fixing within the SAME PR until it passes.`,
                ``,
                `dispatch: ${prd.id}`,
                `time: ${new Date().toISOString()}`
              ].join("\n");

              await github.rest.issues.createComment({
                owner, repo,
                issue_number: driverPr,
                body,
              });
            }

            async function commentFixCI(prNumber, sha, attempt, last) {
              const body = [
                MARKER,
                `@codex Fix ONL
