name: Codex MVP Autopilot (No API Key, No Human Approval)

on:
  push:
    branches: [main, interactive_chain]
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
  schedule:
    - cron: "*/10 * * * *" # every 10 minutes
  workflow_dispatch: {}

concurrency:
  group: codex-mvp-autopilot
  cancel-in-progress: false

permissions:
  contents: write
  pull-requests: write
  issues: write
  checks: read

jobs:
  autopilot:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          # Always operate on the base branch content (prd/index.md must be read from there)
          ref: ${{ vars.CODEX_BASE_BRANCH || 'main' }}

      - name: Pause switch
        run: |
          if [ -f CODEX_PAUSE ]; then
            echo "CODEX_PAUSE present. Exiting."
            exit 0
          fi

      - name: Codex MVP loop (dispatch / fix / merge)
        uses: actions/github-script@v7
        env:
          CODEX_BASE_BRANCH: ${{ vars.CODEX_BASE_BRANCH }}
          MAX_FIX_ATTEMPTS: "8"
        with:
          github-token: ${{ secrets.CODEX_DISPATCH_TOKEN }}
          script: |
            const fs = require("fs");
            const path = require("path");

            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const baseBranch = process.env.CODEX_BASE_BRANCH || "main";
            const MAX_FIX_ATTEMPTS = Number(process.env.MAX_FIX_ATTEMPTS || "8");

            const MVP_ORDER = ["00","01","02","03","04","05","06"];
            const MARKER = "<!-- CODEX_AUTOPILOT -->";

            function codexHeadBranch(prdId) {
              return `codex/${prdId.toLowerCase()}`; // e.g. codex/prd-00
            }

            async function listOpenCodexPRs() {
              const prs = await github.rest.pulls.list({
                owner, repo,
                state: "open",
                base: baseBranch,
                per_page: 100,
              });
              return prs.data.filter(pr => (pr.head.ref || "").startsWith("codex/"));
            }

            async function listComments(issueNumber) {
              const res = await github.rest.issues.listComments({
                owner, repo,
                issue_number: issueNumber,
                per_page: 100,
              });
              return res.data;
            }

            function parseLastFixAttempt(comments) {
              const fixes = comments
                .filter(c => (c.body || "").includes(MARKER) && (c.body || "").includes("fix-attempt"))
                .sort((a,b) => new Date(a.created_at) - new Date(b.created_at));
              if (fixes.length === 0) return { count: 0, lastSha: null };
              const last = fixes[fixes.length - 1];
              const m = (last.body || "").match(/sha:\s*([0-9a-f]{7,40})/i);
              return { count: fixes.length, lastSha: m ? m[1] : null };
            }

            function hasDispatchForPRD(comments, prdId) {
              return comments.some(c =>
                (c.body || "").includes(MARKER) &&
                (c.body || "").includes(`dispatch: ${prdId}`)
              );
            }

            function pickNextPRD() {
              const idxPath = path.join(process.cwd(), "prd", "index.md");
              if (!fs.existsSync(idxPath)) return null;

              const lines = fs.readFileSync(idxPath, "utf-8").split(/\r?\n/);

              let nextId = null;
              for (const pid of MVP_ORDER) {
                const re = new RegExp(`^- \\[TODO\\] PRD-${pid}\\b`);
                if (lines.some(l => re.test(l))) { nextId = pid; break; }
              }
              if (!nextId) return null;

              const prdDir = path.join(process.cwd(), "prd");
              const files = fs.readdirSync(prdDir).filter(f => f.startsWith(`PRD-${nextId}-`) && f.endsWith(".md"));
              if (files.length === 0) return { id: `PRD-${nextId}`, file: null };
              files.sort();
              return { id: `PRD-${nextId}`, file: `prd/${files[0]}` };
            }

            async function getCheckSummary(sha) {
              const res = await github.rest.checks.listForRef({
                owner, repo,
                ref: sha,
                per_page: 100,
              });
              const runs = res.data.check_runs || [];
              const completed = runs.filter(r => r.status === "completed");
              const anyFailed = completed.some(r =>
                ["failure", "cancelled", "timed_out", "action_required", "stale"].includes(r.conclusion)
              );
              const anyInProgress = runs.some(r => r.status !== "completed");
              return { anyFailed, anyInProgress, runs, completed };
            }

            async function getMergeable(prNumber) {
              for (let i = 0; i < 6; i++) {
                const pr = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
                if (pr.data.mergeable !== null) return pr.data.mergeable;
                await new Promise(r => setTimeout(r, 1500));
              }
              const pr = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
              return pr.data.mergeable;
            }

            async function commentFixCI(prNumber, sha, attempt, lastSha) {
              const body = [
                MARKER,
                `@codex Fix ONLY the CI failures for this PR. Do NOT add features. Do NOT refactor unrelated code.`,
                ``,
                `fix-attempt: ${attempt}/${MAX_FIX_ATTEMPTS}`,
                `sha: ${sha}`,
                lastSha ? `previous-attempt-sha: ${lastSha}` : "",
                `time: ${new Date().toISOString()}`
              ].filter(Boolean).join("\n");

              await github.rest.issues.createComment({
                owner, repo,
                issue_number: prNumber,
                body,
              });
            }

            async function commentCodexDispatch(prNumber, prd) {
              const head = codexHeadBranch(prd.id);

              const body = [
                MARKER,
                `@codex Implement **${prd.id}** in THIS PR only.`,
                ``,
                `Rules (must follow):`,
                `- Read: \`agent.md\`, \`process.txt\`, \`prd/index.md\`, and \`${prd.file}\`.`,
                `- Implement ONLY the PRD "In Scope".`,
                `- **Do NOT create another PR. Do NOT change branches.**`,
                `- Commit changes to THIS PR branch (\`${head}\`).`,
                `- **Do NOT add new npm dependencies** (npm registry may be blocked). Use Node built-ins only.`,
                `- Run the PRD Test Steps and report results in the PR description.`,
                `- Update \`prd/index.md\`: mark ${prd.id} as DONE.`,
                `- Append a new round block to \`process.txt\` (Goal / shipped / acceptance / lessons / next).`,
                ``,
                `dispatch: ${prd.id}`,
                `time: ${new Date().toISOString()}`
              ].join("\n");

              await github.rest.issues.createComment({
                owner, repo,
                issue_number: prNumber,
                body,
              });
            }

            async function mergePR(pr) {
              await github.rest.pulls.merge({
                owner, repo,
                pull_number: pr.number,
                merge_method: "squash",
                commit_title: `Automerge: ${pr.title}`,
              });
            }

            async function createStuckIssue(pr, msg) {
              await github.rest.issues.create({
                owner, repo,
                title: `Codex autopilot stuck: PR #${pr.number} (${pr.title})`,
                body: [
                  MARKER,
                  `Autopilot could not progress.`,
                  ``,
                  `PR: #${pr.number}`,
                  `Head: ${pr.head.ref} @ ${pr.head.sha}`,
                  ``,
                  msg,
                  ``,
                  `Recommended action: add CODEX_PAUSE file to stop the loop, then inspect.`
                ].join("\n"),
              });
            }

            // Create a seed commit so the PR can exist (GitHub disallows PR with no diffs)
            async function seedBranchDiff(headRef, prdId) {
              const headName = headRef.replace(/^refs\/heads\//, "");

              const baseRef = await github.rest.git.getRef({ owner, repo, ref: `heads/${baseBranch}` });
              const baseSha = baseRef.data.object.sha;

              const baseCommit = await github.rest.git.getCommit({ owner, repo, commit_sha: baseSha });
              const baseTreeSha = baseCommit.data.tree.sha;

              const seedPath = `.codex/seed-${prdId}.md`;
              const seedContent = [
                `# Autopilot seed for ${prdId}`,
                ``,
                `This file exists only to create a non-empty diff so GitHub can open a PR.`,
                `Codex may modify or delete it if the PRD does not need it.`,
                ``,
                `Created at: ${new Date().toISOString()}`,
              ].join("\n");

              const blob = await github.rest.git.createBlob({
                owner, repo,
                content: seedContent,
                encoding: "utf-8",
              });

              const tree = await github.rest.git.createTree({
                owner, repo,
                base_tree: baseTreeSha,
                tree: [
                  { path: seedPath, mode: "100644", type: "blob", sha: blob.data.sha }
                ],
              });

              const commit = await github.rest.git.createCommit({
                owner, repo,
                message: `chore: start ${prdId}`,
                tree: tree.data.sha,
                parents: [baseSha],
              });

              await github.rest.git.updateRef({
                owner, repo,
                ref: `heads/${headName}`,
                sha: commit.data.sha,
                force: true,
              });
            }

            async function ensureCodexPR(prd) {
              const head = codexHeadBranch(prd.id); // codex/prd-00

              // if PR already exists, return it
              const existing = await github.rest.pulls.list({
                owner, repo, state: "open", base: baseBranch, per_page: 100
              });
              const found = existing.data.find(p => p.head.ref === head);
              if (found) return found;

              // ensure branch exists
              const baseRef = await github.rest.git.getRef({ owner, repo, ref: `heads/${baseBranch}` });
              const baseSha = baseRef.data.object.sha;

              try {
                await github.rest.git.createRef({
                  owner, repo,
                  ref: `refs/heads/${head}`,
                  sha: baseSha,
                });
              } catch (e) {
                if (!String(e.message || "").includes("Reference already exists")) throw e;
              }

              // seed diff so PR can be created
              await seedBranchDiff(`refs/heads/${head}`, prd.id);

              // create PR
              const prRes = await github.rest.pulls.create({
                owner, repo,
                title: `Codex: ${prd.id}`,
                head,
                base: baseBranch,
                body: `${MARKER}\nAutopilot-created PR for ${prd.id}.`,
              });
              return prRes.data;
            }

            // === Main loop ===
            const codexPRs = await listOpenCodexPRs();

            if (codexPRs.length > 1) {
              await createStuckIssue(codexPRs[0], `Multiple open codex/* PRs detected (${codexPRs.length}). Autopilot requires at most 1 at a time.`);
              core.warning(`Multiple open codex PRs (${codexPRs.length}); exiting.`);
              return;
            }

            // If there is exactly one codex PR, manage fix/merge loop
            if (codexPRs.length === 1) {
              const pr = codexPRs[0];
              const checks = await getCheckSummary(pr.head.sha);

              if (checks.anyFailed) {
                const comments = await listComments(pr.number);
                const { count, lastSha } = parseLastFixAttempt(comments);

                // If we already asked Codex to fix this exact SHA, wait
                if (lastSha && lastSha === pr.head.sha) {
                  core.info(`CI failing but fix already requested for current SHA. Waiting.`);
                  return;
                }

                if (count >= MAX_FIX_ATTEMPTS) {
                  await createStuckIssue(pr, `Exceeded MAX_FIX_ATTEMPTS (${MAX_FIX_ATTEMPTS}) while CI keeps failing. Last SHA: ${pr.head.sha}`);
                  core.warning(`Exceeded fix attempts for PR #${pr.number}.`);
                  return;
                }

                await commentFixCI(pr.number, pr.head.sha, count + 1, lastSha);
                core.info(`Requested Codex to fix CI for PR #${pr.number}.`);
                return;
              }

              if (checks.anyInProgress) {
                core.info(`CI in progress for PR #${pr.number}. Waiting.`);
                return;
              }

              const mergeable = await getMergeable(pr.number);
              if (mergeable === false) {
                await createStuckIssue(pr, `PR is not mergeable (conflicts). Ask Codex to resolve conflicts or rebase.`);
                await github.rest.issues.createComment({
                  owner, repo,
                  issue_number: pr.number,
                  body: [
                    MARKER,
                    `@codex Resolve merge conflicts ONLY for this PR. Do not change scope. Rebase/merge onto ${baseBranch} as needed.`,
                    `sha: ${pr.head.sha}`,
                    `time: ${new Date().toISOString()}`
                  ].join("\n")
                });
                return;
              }

              try {
                await mergePR(pr);
                core.info(`Merged PR #${pr.number}. Next tick will dispatch next PRD.`);
              } catch (e) {
                core.warning(`Merge attempt failed for PR #${pr.number}: ${e.message}`);
              }
              return;
            }

            // No open codex PR: create/find PR for next PRD and dispatch ONCE in that PR
            const prd = pickNextPRD();
            if (!prd) {
              core.info("No TODO PRD in MVP path (00-06). MVP loop complete.");
              return;
            }
            if (!prd.file) {
              await github.rest.issues.create({
                owner, repo,
                title: `Codex autopilot error: missing PRD file for ${prd.id}`,
                body: `${MARKER}\nCould not find a prd/${prd.id}-*.md file. Fix prd directory.`,
              });
              return;
            }

            const prWork = await ensureCodexPR(prd);
            const prComments = await listComments(prWork.number);

            // Dispatch only once per PRD PR to avoid spam
            if (!hasDispatchForPRD(prComments, prd.id)) {
              await commentCodexDispatch(prWork.number, prd);
              core.info(`Dispatched ${prd.id} in PR #${prWork.number} (${prWork.head.ref}).`);
            } else {
              core.info(`${prd.id} already dispatched in PR #${prWork.number}. Waiting for Codex/CI.`);
            }
